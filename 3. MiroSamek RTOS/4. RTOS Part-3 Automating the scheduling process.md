#### Automating the scheduling process
- For the simple example of two threads, where the `PendSV` interrupt is pended at the end of the `SysTick` interrupt, we can simply switch the context alternatively and the concurrent execution will occur. We will think on how to extend this in a more general and flexible way if more threads are present.
- *Coding note: we don't want to change the behavior of the code, it already behaves according to your requirements. Instead, you want to improve the internal design, which is called "Refactoring".*

##### Implementing a simple round robin scheduler
- Generally, RTOS implement the thread control block in a linked list and the scheduler code travels each block one-by-one in a round robin fashion, to handle concurrent threads.
- In our simple example, it is enough to store these thread pointers(*which currently consists of only the top of the stack variable*) in an array and do the context switch to the next thread one-by-one in a circular fashion in the `PendSV` handler.
- *Coding notes*
	- ***Assertions**: At this point, you are making an implicit assumption that you are not overflowing the thread array. Such assumptions should be enforced somehow. The typical way is to check the index and return an error code to the caller when it overflows. But then the caller can simply ignore the problem. A better way for such situations, is to use assertions. The C language provides a standard assert() facility, which evaluates the expression and when it turns out to be false, the assert() macro prints a message to the screen and exits the application. Neither of these actions make sense in a deeply embedded programming, where you have no screen to print to and you cannot really exit either. So instead, I use here an embedded systems-friendly assertion `Q_ASSERT()` that simply checks the expression, and if it turns out to be false, it calls the special callback function `Q_onAssert()`. You have this function already defined in the `bsp.c` file, because the startup code is already using assertions. This function can and should be carefully customized to your specific project. This is your last line of defense after the code already failed. When this happens, you should try to do damage control and log or somehow output the location of the assertion, which is provided in the module and loc parameters. After this, you typically you should reset the system, to avoid the denial of service failure. I hope to talk more about assertions and the philosophy called Design by Contract in the future lessons.*
	- ***Composability:** The advantage of this design is that you no longer need to hard-code the threads from the application, because the RTOS "registers" every newly started thread and automatically includes it in the round-robin scheduling. As you can see, the addition of a new thread is confined to the main file and does not require changing any of the existing threads or the RTOS code. This property of threads is called composability. Please note that threads became composable only after adding the RTOS, because without it you could not easily combine them to run seemingly simultaneously and independently from each other.*
- The interrupts must always be enabled after the threads are registered, because if an interrupt were to fire before you reach the end of main, such an interrupt might trigger a context switch which takes the control away from main and never really returns. This means that some important initialization code might not get executed and some of the threads might not get started.
- The correct timeline of RTOS initialization is for the system to configure and start interrupts only after all threads have been started. This means that the right place to do this is at the end of main.
- The `PendSV` exception will run immediately after the interrupts are re-enabled, so the control will really never return back to `main()` and can be captured using `Q_ERROR()` if by any chance the control reaches back to `main()`.

##### Overhead of context switching
- Some timing parameters
	- The time between the last activity of a thread and the trigger, which is at the beginning of the `SysTick` interrupt.
	- The time spent inside the `SysTick_Handler()`
	- The context switching time after the `SysTick` exits but before the next thread starts
- Gathering these timings, we can estimate the ratio of the CPU time spent inside the RTOS for things like scheduling and context switching to the total CPU time. This can tell us how often we need to run the scheduler, i.e. the `SysTick` interrupt in our case. Generally the overhead is small.