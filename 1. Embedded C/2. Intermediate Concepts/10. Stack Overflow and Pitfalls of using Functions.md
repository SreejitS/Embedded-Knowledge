## Lesson 10: Stack Overflow and other Pitfalls of Functions
- Automatic variables(unassigned variables inside of a function) have garbage values in them as stack just assigns the space for them and doesn't waste any clock cycles for putting any values in them, they get their values from previous uses of RAM/stack. 
- If overflow occurs, the stack(maybe by recursively calling into functions having large arrays of variables), the SP may bottom out the stack and will reach beginning of the RAM and processor may have bus fault exception(CPU is forced to access non existent memory).
- Stack is for automatic variables, return addresses and arguments. Heaps are for dynamic memory allocation. Accessing beyond memory bounds(arrays are stored with its maximum index at near the beginning of the stack) in automatic arrays will change the content at that location in stack intended for some other purpose and may corrupt the return indexes/automatic variables and arguments. This [[https://youtu.be/jmzvued3w3Y?t=933|MAY]] cause it to return to some other lower address by coincidence and start executing vector table and then main again without popping main's initial frame. In this case the stack grows slowly and overflows. Check SP whenever fault occurs. 
- Return addresses are odd as the LSB is thumb2 bit. 
- Arguments are passed by value by default meaning the argument's value is copied to the internal variable to initialize it, so the function uses this internal copy rather that the original argument. Pointer arguments are used for passing by reference.
- Inside a function, if pointers to local variables are returned they will go out of scope when the function returns. Pointers to local variables are stored in stack and will go out of scope(i.e. SP points below the variable and cannot access them) when the function returns. so don't return pointers to local variables from the function. So to do it correctly, use local variables that are not on the stack that is use the static keyword. The word static in this context means that the amount of memory allocated for this kind of variables does not change while the application is running. This tells the compiler to allocate memory outside the stack so that it outlives the function even when it returns.
 